import { useState, useEffect, useContext, useRef } from "react";
import style from "../styles/Game.module.css";
import Link from "next/link";
import Head from "next/head";
import {
  SquaresContext,
  ResultContext,
  HandleTileClickContext,
  IsSinglePlayerContext,
} from "../contexts/TicTacToeContext";

export default function App() {
  const [squares, setSquares] = useState(Array(9).fill(null));
  const [currentPlayer, setCurrentPlayer] = useState("X");
  const [theme, setTheme] = useState(null);
  const [isSinglePlayer, setIsSinglePlayer] = useState(true);
  const [isBoardEnabled, setIsBoardEnabled] = useState(true);
  const [easyMode, setEasyMode] = useState(true);
  const resultRef = useRef(null);

  const swapPlayer = () => setCurrentPlayer(currentPlayer === "X" ? "O" : "X");
  const handleChangeTheme = () => {
    setTheme(theme === "dark" ? "light" : "dark");
  };

  useEffect((theme) => {
    setTheme(
      window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light"
    );
    document.body.className = `${style[theme]}`;
  }, []);

  const delay = (ms) => new Promise((res) => setTimeout(res, ms));

  const callAPI = async (dataToSend) => {
    try {
      const res = await fetch("http://localhost:3000/api/hello", {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ first: dataToSend }),
      });
      const data = await res.json();
      return data;
    } catch (err) {
      console.error(err);
    }
  };

  const handleTileClick = async (index) => {
    //return if gameOver or tile is clicked already
    if (resultRef.current || squares[index]) return;
    //rerender square with clicked square
    const newSquares = [...squares];
    newSquares[index] = currentPlayer;
    setSquares(newSquares);
    resultRef.current = getResult(newSquares); //update result
    //if game ended or single player, quit function
    if (resultRef.current || !isSinglePlayer) {
      swapPlayer();
      return;
    }
    //game not ended and is single player
    setIsBoardEnabled(false);
    await delay(300)
      .then(() => {
        //return anyhowBotMove(newSquares);             //anyhowBotMove
        //return callAPI(newSquares);                   //api call for best move
        return bestBotMove(newSquares);
      })
      .then((botMove) => {
        newSquares[botMove] = currentPlayer === "X" ? "O" : "X";
        resultRef.current = getResult(newSquares);
        setSquares(newSquares);
        setIsBoardEnabled(true);
      })
      .catch((err) => console.log(err));
  };

  const handleReset = () => {
    resultRef.current = null;
    setSquares(Array(9).fill(null));
    setCurrentPlayer("X");
  };

  const handlePlayerModeToggle = () => {
    setIsSinglePlayer(isSinglePlayer === true ? false : true);
    handleReset();
  };

  return (
    <>
      <Head>
        <title>Tic-Tac-Toe</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${style.main} ${style[theme]}`}>
        <MenuBar theme={theme} setTheme={handleChangeTheme} />
        <GameContextWrapper
          handleTileClick={handleTileClick}
          squares={squares}
          result={resultRef.current}
          isSinglePlayer={isSinglePlayer}
        >
          <GameContainer
            currentPlayer={currentPlayer}
            handleReset={handleReset}
            handlePlayerModeToggle={handlePlayerModeToggle}
            isBoardEnabled={isBoardEnabled}
          />
        </GameContextWrapper>
      </main>
    </>
  );
}

function MenuBar({ setTheme }) {
  return (
    <>
      <Link href="/" className={`${style.homeLink}`}>
        <u>Home</u>
      </Link>
      <button
        className={`${style.themeSelector}`}
        onClick={() => setTheme()}
      ></button>
    </>
  );
}

function GameContextWrapper(props) {
  return (
    <HandleTileClickContext.Provider value={props.handleTileClick}>
      <SquaresContext.Provider value={props.squares}>
        <ResultContext.Provider value={props.result}>
          <IsSinglePlayerContext.Provider value={props.isSinglePlayer}>
            {props.children}
          </IsSinglePlayerContext.Provider>
        </ResultContext.Provider>
      </SquaresContext.Provider>
    </HandleTileClickContext.Provider>
  );
}

function GameContainer(props) {
  return (
    <div className={style.gameContainer}>
      <Grid isBoardEnabled={props.isBoardEnabled} />
      <GameMenuBar {...props} />
    </div>
  );
}

function GameMenuBar({ handleReset, currentPlayer, handlePlayerModeToggle }) {
  const isSinglePlayer = useContext(IsSinglePlayerContext);
  const result = useContext(ResultContext);
  return (
    <div className={`${style.infoContainer}`}>
      <button className={`${style.resetButton}`} onClick={handleReset}>
        Reset
      </button>
      <button className={`${style.resetButton} ${result && style.celebrate}`}>
        {resultButtonText(result, currentPlayer)}
      </button>
      <button
        className={`${style.resetButton}`}
        onClick={handlePlayerModeToggle}
      >
        {isSinglePlayer ? "2P" : "1P"}
      </button>
    </div>
  );
}

function Grid({ isBoardEnabled }) {
  return (
    <div className={`${style.board} ${!isBoardEnabled && style.disableClick}`}>
      <Square index={0} />
      <Square index={1} />
      <Square index={2} />
      <Square index={3} />
      <Square index={4} />
      <Square index={5} />
      <Square index={6} />
      <Square index={7} />
      <Square index={8} />
    </div>
  );
}

function Square({ index }) {
  const result = useContext(ResultContext);
  const squares = useContext(SquaresContext);
  const onClick = useContext(HandleTileClickContext);

  const winningCombination = Array.isArray(result) ? [...result] : [];
  const isIconDisabled = result ? "icon-disabled" : "";
  const appearClass = squares[index] ? "appear" : "";

  return (
    <div
      className={`${style.square} ${style[indexToPositionList[index]]}`}
      onClick={() => onClick(index)}
    >
      <div
        className={`${style[appearClass]} ${style[isIconDisabled]} ${
          winningCombination.includes(index) && style.winTile
        }`}
      >
        {squares[index]}
      </div>
    </div>
  );
}

const winningCombinations = [
  [0, 1, 2],
  [3, 4, 5],
  [6, 7, 8],
  [0, 3, 6],
  [1, 4, 7],
  [2, 5, 8],
  [0, 4, 8],
  [2, 4, 6],
];

const indexToPositionList = [
  "topLeft",
  "top",
  "topRight",
  "middleLeft",
  "middle",
  "middleRight",
  "bottomLeft",
  "bottom",
  "bottomRight",
];

//decides what text to put on gameState info button
const resultButtonText = (result, currentPlayer) => {
  switch (result) {
    case "draw":
      return "It's a draw!";
    case null:
      return `${currentPlayer}, your turn now!`;
    default:
      return `${result[3]} wins!`;
  }
};

//returns win-combination indexes+winner or draw or null
function getResult(squares) {
  for (let i = 0; i < winningCombinations.length; i++) {
    const [a, b, c] = winningCombinations[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return [a, b, c, squares[a]];
    }
  }
  if (squares.every((square) => square !== null)) {
    return "draw";
  }
  return null;
}

const anyhowBotMove = (squares) => {
  const emptyIndexes = squares
    .map((square, index) => (!square ? index : null))
    .filter((index) => index !== null);
  if (!emptyIndexes.length) return;
  return emptyIndexes[Math.floor(Math.random() * emptyIndexes.length)];
};

const bestBotMove = (squares) => {
  const possibleMoves = squares
    .map((square, index) => (!square ? index : null))
    .filter((index) => index !== null);
  const miniMaxValues = possibleMoves.map((move) =>
    miniMax(move, possibleMoves, false, squares)
  );
  const indexOfBestMove = miniMaxValues.indexOf(Math.min(...miniMaxValues));
  return possibleMoves[indexOfBestMove];
};

//X / player is maximizer, O / Bot is minimizer
const miniMax = (selectedMove, moves, isMaximizer, gameBoard) => {
  const newGameBoard = [...gameBoard];
  newGameBoard[selectedMove] = isMaximizer ? "X" : "O";
  const result = getResult(newGameBoard);
  if (result) {
    if (result === "draw") return 0;
    if (result[3] === "X") return 5;
    if (result[3] === "O") return -5;
  }
  const newMoves = moves.filter((move) => move !== selectedMove);
  const miniMaxValues = newMoves.map((move) =>
    miniMax(move, newMoves, !isMaximizer, newGameBoard)
  );
  if (isMaximizer) return Math.min(...miniMaxValues);
  return Math.max(...miniMaxValues);
};
